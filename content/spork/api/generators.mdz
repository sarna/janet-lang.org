(import ../../gen-docs :as gen-docs)
(import spork/generators :export true)
(setdyn :source-linker (partial gen-docs/github-source-linker "janet-lang/spork" gen-docs/spork-version))
(setdyn :no-community-examples true)

{:title "generators"
 :author "Z. D. Smith"
 :license "BSD3"
 :template "docpage.html"}
---

Eager evaluation costs a lot of memory when you need to process lots of data in a chain of eagerly evaluated functions
as shown below.

@codeblock[janet]```
(->> big-data
     (map inc)
     (filter even?)
     # ... more eagerly evaluated functions
     )
```

The above code can create huge intermediate results which will be discarded by garbage collector later. You can avoid
creating huge intermediate results with lazily evaluated generator functions in this module. Unlike lazy sequences in
haskell and clojure, fiber-based generators don't cache values and don't leak memory.

A @strong[generator] is an iterable coroutine which yields individual values whenever it is resumed, potentially until
its internal values are exhausted, at which point it's considered dead. A coroutine is just another name for a fiber. A
fiber is an iterable type that can be consumed by any of janet's core functions that expect iterable data types. A
generator function can consume other generators and fully realized iterable data types produced by janet's core
functions. In other words, iterables can generally be used interchangeably regardless of whether they are evaluated
eagerly or lazily.

This operation makes them very useful for:

@ul{@li{Asynchronous behaviour}
    @li{Memory-sensitive applications, where it's not necessary to keep an entire sequence in memory at once}
    @li{Infinite sequences}}

Note: Certain functions (specifically @code`run` and @code`to-array`) will create an infinite loop if their argument is
an infinite generator!

## Reference

@gen-docs/gen-prefix-current[generators/]

